From 9e5e9fddac59c6ab6b65b58890d20e228677e311 Mon Sep 17 00:00:00 2001
From: Xiaoguang Chen <xiaoguang.chen@intel.com>
Date: Fri, 28 Apr 2017 14:10:02 +0800
Subject: [PATCH] GVT-g compositor display using GVT-g's dmabuf

This is an example implementation on how to use the GVT-g's dmabuf to show
the desktop of a vm which use the intel vgpu.

This patch is based on QEMU 2.7.

Signed-off-by: xiaoguang chen <xiaoguang.chen@intel.com>
---
 configure                     |   7 +
 hw/vfio/pci.c                 |  28 ++
 include/hw/vfio/vfio-common.h |   2 +
 include/ui/console.h          |   1 +
 linux-headers/linux/vfio.h    |   1 +
 roms/seabios                  |   2 +-
 ui/Makefile.objs              |   2 +
 ui/intel_vgt.c                | 672 ++++++++++++++++++++++++++++++++++++++++++
 ui/sdl.c                      |  16 +-
 vl.c                          |   3 +
 10 files changed, 728 insertions(+), 6 deletions(-)
 create mode 100644 ui/intel_vgt.c

diff --git a/configure b/configure
index 4b808f9..a4427b1 100755
--- a/configure
+++ b/configure
@@ -2539,6 +2539,13 @@ EOF
   libs_softmmu="$sdl_libs $libs_softmmu"
 fi
 
+if test "$sdl" = "yes" ; then
+  vgpu_cflags=`$pkg_config --cflags egl 2> /dev/null`
+  vgpu_libs=`$pkg_config --libs libdrm sdl gl egl libudev 2> /dev/null`
+  QEMU_CFLAGS="$QEMU_CFLAGS $vgpu_cflags"
+  libs_softmmu="$libs_softmmu $vgpu_libs"
+fi
+
 ##########################################
 # RDMA needs OpenFabrics libraries
 if test "$rdma" != "no" ; then
diff --git a/hw/vfio/pci.c b/hw/vfio/pci.c
index 7bfa17c..6aaec51 100644
--- a/hw/vfio/pci.c
+++ b/hw/vfio/pci.c
@@ -38,6 +38,32 @@
 static void vfio_disable_interrupts(VFIOPCIDevice *vdev);
 static void vfio_mmap_set_enabled(VFIOPCIDevice *vdev, bool enabled);
 
+VFIOPCIDevice *kvmgt_vdev;
+int kvmgt_get_anon_fd(void)
+{
+    struct vfio_region_info *anon_fd;
+    int ret;
+    int fd;
+
+    ret = vfio_get_dev_region_info(&kvmgt_vdev->vbasedev,
+                    VFIO_REGION_TYPE_PCI_VENDOR_TYPE | PCI_VENDOR_ID_INTEL,
+                    VFIO_REGION_SUBTYPE_INTEL_IGD_GVTG, &anon_fd);
+    if (ret) {
+        error_report("Device %s does not support requested IGD anon fd "
+                     "feature", kvmgt_vdev->vbasedev.name);
+        return -100;
+    }
+
+    ret = pread(kvmgt_vdev->vbasedev.fd, &fd, anon_fd->size, anon_fd->offset);
+    if (ret != anon_fd->size) {
+        error_report("vfio: Error reading IGD anon fd");
+        return -EINVAL;
+    }
+    printf("kvmgt: get anon fd:%d\n", fd);
+
+    return fd;
+}
+
 /*
  * Disabling BAR mmaping can be slow, but toggling it around INTx can
  * also be a huge overhead.  We try to get the best of both worlds by
@@ -2513,6 +2539,8 @@ static int vfio_initfn(PCIDevice *pdev)
     vdev->vbasedev.ops = &vfio_pci_ops;
     vdev->vbasedev.type = VFIO_DEVICE_TYPE_PCI;
 
+    kvmgt_vdev = vdev;
+
     tmp = g_strdup_printf("%s/iommu_group", vdev->vbasedev.sysfsdev);
     len = readlink(tmp, group_path, sizeof(group_path));
     g_free(tmp);
diff --git a/include/hw/vfio/vfio-common.h b/include/hw/vfio/vfio-common.h
index 94dfae3..5f9fe64 100644
--- a/include/hw/vfio/vfio-common.h
+++ b/include/hw/vfio/vfio-common.h
@@ -175,4 +175,6 @@ int vfio_spapr_create_window(VFIOContainer *container,
 int vfio_spapr_remove_window(VFIOContainer *container,
                              hwaddr offset_within_address_space);
 
+int kvmgt_get_anon_fd(void);
+
 #endif /* HW_VFIO_VFIO_COMMON_H */
diff --git a/include/ui/console.h b/include/ui/console.h
index 2703a3a..e3cf09c 100644
--- a/include/ui/console.h
+++ b/include/ui/console.h
@@ -427,6 +427,7 @@ void surface_gl_setup_viewport(ConsoleGLState *gls,
 #ifdef CONFIG_SDL
 void sdl_display_early_init(int opengl);
 void sdl_display_init(DisplayState *ds, int full_screen, int no_frame);
+void intel_vgpu_display_init(DisplayState *ds, int full_screen, int no_frame);
 #else
 static inline void sdl_display_early_init(int opengl)
 {
diff --git a/linux-headers/linux/vfio.h b/linux-headers/linux/vfio.h
index 759b850..8f1f07e 100644
--- a/linux-headers/linux/vfio.h
+++ b/linux-headers/linux/vfio.h
@@ -287,6 +287,7 @@ struct vfio_region_info_cap_type {
 #define VFIO_REGION_SUBTYPE_INTEL_IGD_OPREGION	(1)
 #define VFIO_REGION_SUBTYPE_INTEL_IGD_HOST_CFG	(2)
 #define VFIO_REGION_SUBTYPE_INTEL_IGD_LPC_CFG	(3)
+#define VFIO_REGION_SUBTYPE_INTEL_IGD_GVTG	(4)
 
 /**
  * VFIO_DEVICE_GET_IRQ_INFO - _IOWR(VFIO_TYPE, VFIO_BASE + 9,
diff --git a/roms/seabios b/roms/seabios
index e2fc41e..81d62cb 160000
--- a/roms/seabios
+++ b/roms/seabios
@@ -1 +1 @@
-Subproject commit e2fc41e24ee0ada60fc511d60b15a41b294538be
+Subproject commit 81d62cb79013c615ce9f5221a6398fca2012e3f1
diff --git a/ui/Makefile.objs b/ui/Makefile.objs
index dc936f1..9c543ce 100644
--- a/ui/Makefile.objs
+++ b/ui/Makefile.objs
@@ -12,6 +12,7 @@ common-obj-y += input.o input-keymap.o input-legacy.o
 common-obj-$(CONFIG_LINUX) += input-linux.o
 common-obj-$(CONFIG_SPICE) += spice-core.o spice-input.o spice-display.o
 common-obj-$(CONFIG_SDL) += sdl.mo x_keymap.o
+common-obj-$(CONFIG_SDL) += intel_vgt.o
 common-obj-$(CONFIG_COCOA) += cocoa.o
 common-obj-$(CONFIG_CURSES) += curses.o
 common-obj-$(CONFIG_VNC) += $(vnc-obj-y)
@@ -27,6 +28,7 @@ sdl.mo-objs += sdl2-gl.o
 endif
 endif
 sdl.mo-cflags := $(SDL_CFLAGS)
+intel_vgt.o-cflags := $(SDL_CFLAGS)
 
 ifeq ($(CONFIG_OPENGL),y)
 common-obj-y += shader.o
diff --git a/ui/intel_vgt.c b/ui/intel_vgt.c
new file mode 100644
index 0000000..e162e98
--- /dev/null
+++ b/ui/intel_vgt.c
@@ -0,0 +1,672 @@
+/*
+ * QEMU Intel GVT-g indirect display support
+ *
+ * Copyright (c) Intel
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2.  See
+ * the COPYING file in the top-level directory.
+ *
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <limits.h>
+
+#define __user
+#include <xf86drm.h>
+#include <drm_fourcc.h>
+
+#include "qemu/osdep.h"
+#include <SDL.h>
+#include <SDL_syswm.h>
+
+#include <libudev.h>
+
+#include "sysemu/sysemu.h"
+#include "qemu-common.h"
+#include "ui/console.h"
+#include "hw/xen/xen.h"
+
+#include <GL/gl.h>
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+
+#include <hw/vfio/vfio-common.h>
+#include <sys/ioctl.h>
+
+/* we hard code the vgpuid to 1
+ * we use the vgpuid to check the vm's display ready event once getting
+ * the event switching to use intel vgpu display before that we use the
+ * emulated grahics card. This may not needed while using other display
+ * method such as spice.
+ */
+int vgpuid = 1;
+
+static GLuint textureId = 0;
+static GLuint cursortextureId = 0;
+static int fbWidth = 0;
+static int fbHeight = 0;
+
+static int winWidth = 1024;
+static int winHeight = 768;
+
+const int PRIMARY_LIST_LEN = 3;
+const int CURSOR_LIST_LEN = 4;
+
+static uint32_t current_primary_fb_addr = 0;
+static uint32_t current_cursor_fb_addr = 0;
+static GLuint current_textureId;
+static GLuint current_cursor_textureId;
+static bool cursor_ready = false;
+
+static int kvmgt_fd = 0;
+
+typedef struct buffer_rec{
+    uint32_t start;
+    GLuint textureId;
+    int age;
+    uint8_t tiled;
+    uint32_t size;
+    int fd;
+} buffer_rec;
+
+typedef struct buffer_list{
+    struct buffer_rec *l;
+    int len;
+} buffer_list;
+
+struct buffer_list primary_list;
+struct buffer_list cursor_list;
+
+static EGLDisplay dpy;
+static EGLContext ctx;
+static EGLSurface sur;
+
+PFNGLEGLIMAGETARGETTEXTURE2DOESPROC glEGLImageTargetTexture2DOES;
+PFNEGLCREATEIMAGEKHRPROC eglCreateImageKHR;
+PFNEGLDESTROYIMAGEKHRPROC eglDestroyImageKHR;
+
+#define INTEL_VGPU_QUERY_DMABUF         0
+#define INTEL_VGPU_GENERATE_DMABUF      1
+
+struct intel_vgpu_dmabuf {
+        __u32 plane_id;
+#define INTEL_GVT_PLANE_PRIMARY         1
+#define INTEL_GVT_PLANE_SPRITE          2
+#define INTEL_GVT_PLANE_CURSOR          3
+        /* out */
+        __u32 fd;
+        __u32 drm_format;
+        __u32 width;
+        __u32 height;
+        __u32 stride;
+        __u32 start;
+        __u32 x_pos;
+        __u32 y_pos;
+        __u32 size;
+        __u32 tiled;
+};
+
+static int kvmgt_fd_ioctl(int fd, int type, ...)
+{
+    int ret;
+    void *arg;
+    va_list ap;
+
+    va_start(ap, type);
+    arg = va_arg(ap, void *);
+    va_end(ap);
+
+    ret = ioctl(fd, type, arg);
+    if (ret < 0) {
+        ret = -errno;
+    }
+
+    return ret;
+}
+
+static void drawRect(void)
+{
+    /*
+     * The framebuffer is top-down flipped.
+     * Set flipped texture coords to correct it.
+     */
+
+    glBegin(GL_QUADS);
+    glTexCoord2f(0, 1);  glVertex3f(-1, -1, 0);
+    glTexCoord2f(1, 1);  glVertex3f(1, -1, 0);
+    glTexCoord2f(1, 0);  glVertex3f(1, 1, 0);
+    glTexCoord2f(0, 0);  glVertex3f(-1, 1, 0);
+    glEnd();
+}
+
+static void draw(int x, int y)
+{
+    float fx, fy;
+
+    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+    glLoadIdentity();
+
+    /* Draw the primary plane in a rectangle. */
+    glBindTexture(GL_TEXTURE_2D, current_textureId);
+    glDisable(GL_BLEND);
+    drawRect();
+
+    if (cursor_ready) {
+        /* Calcuate the cursor position. */
+        fx = -1 + 2 * (float)(x + 32) / (float)fbWidth;
+        fy = 1 - 2 * (float)(y + 32) / (float)fbHeight;
+        glTranslatef(fx, fy, 0);
+        glScalef(64 / (float)fbWidth, 64 / (float)fbHeight, 1);
+
+        /* Draw the cursor plane in another rectangle */
+        glBindTexture(GL_TEXTURE_2D, current_cursor_textureId);
+        glEnable(GL_BLEND);
+        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+        drawRect();
+    }
+
+    glFlush();
+}
+
+/* new window size or exposure */
+static void reshape(int width, int height)
+{
+    glViewport(0, 0, width, height);
+}
+
+static int find_rec(struct buffer_list *l, struct intel_vgpu_dmabuf
+                    *dmabuf)
+{
+    int i, r;
+
+    r = -1;
+    for (i = 0; i < l->len; i++) {
+        if (l->l[i].start == dmabuf->start &&
+            l->l[i].tiled == dmabuf->tiled &&
+            l->l[i].size == dmabuf->size) {
+            r = i;
+            break;
+        }
+    }
+
+    return r;
+}
+
+static int oldest_rec(struct buffer_list *l)
+{
+    int i = 1, a = l->l[0].age, r = 0;
+
+    for (i = 1; i < l->len; i++) {
+        if (l->l[i].age > a) {
+            a = l->l[i].age;
+            r = i;
+        }
+    }
+
+    return r;
+}
+
+static void age_list(struct buffer_list *l)
+{
+    int i;
+
+    for (i = 0; i < l->len; i++) {
+        if (l->l[i].age != INT_MAX) {
+            l->l[i].age++;
+        }
+    }
+}
+
+static void create_cursor_buffer(void)
+{
+    struct intel_vgpu_dmabuf dmabuf;
+
+    int r, ret;
+    EGLImageKHR namedimage;
+    unsigned long name;
+
+    glGenTextures(1, &cursortextureId);
+    glBindTexture(GL_TEXTURE_2D, cursortextureId);
+
+    current_cursor_textureId = cursortextureId;
+
+    memset(&dmabuf, 0, sizeof(struct intel_vgpu_dmabuf));
+    dmabuf.plane_id = INTEL_GVT_PLANE_CURSOR;
+    ret = kvmgt_fd_ioctl(kvmgt_fd, INTEL_VGPU_GENERATE_DMABUF, &dmabuf);
+    if (ret < 0) {
+        return;
+    }
+    name = dmabuf.fd;
+    current_cursor_fb_addr = dmabuf.start;
+    r = oldest_rec(&primary_list);
+    if (cursor_list.l[r].fd > 0) {
+	printf("close cursor fd:%d/n", cursor_list.l[r].fd);
+        close(cursor_list.l[r].fd);
+    }
+
+    cursor_list.l[r].start = current_cursor_fb_addr;
+    cursor_list.l[r].textureId = cursortextureId;
+    cursor_list.l[r].age = 0;
+    cursor_list.l[r].tiled = 0;
+    cursor_list.l[r].size = dmabuf.size;
+    cursor_list.l[r].fd = dmabuf.fd;
+
+    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+    glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP, GL_TRUE);
+
+    EGLint attribs[] = {
+        EGL_WIDTH, dmabuf.width,
+        EGL_HEIGHT, dmabuf.height,
+        EGL_LINUX_DRM_FOURCC_EXT,
+        dmabuf.drm_format > 0 ? dmabuf.drm_format : DRM_FORMAT_ARGB8888,
+        EGL_DMA_BUF_PLANE0_FD_EXT, (int)name,
+        EGL_DMA_BUF_PLANE0_OFFSET_EXT, 0,
+        EGL_DMA_BUF_PLANE0_PITCH_EXT, dmabuf.stride,
+        EGL_NONE
+    };
+    namedimage = eglCreateImageKHR(dpy, EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT,
+                                   NULL, attribs);
+    glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, namedimage);
+    eglDestroyImageKHR(dpy, namedimage);
+}
+
+static void create_primary_buffer(void)
+{
+    struct intel_vgpu_dmabuf dmabuf;
+    EGLImageKHR namedimage;
+    unsigned long name;
+    int ret;
+    int r;
+
+    glGenTextures(1, &textureId);
+    glBindTexture(GL_TEXTURE_2D, textureId);
+
+
+    current_textureId = textureId;
+
+    memset(&dmabuf, 0, sizeof(struct intel_vgpu_dmabuf));
+    dmabuf.plane_id = INTEL_GVT_PLANE_PRIMARY;
+    ret = kvmgt_fd_ioctl(kvmgt_fd, INTEL_VGPU_GENERATE_DMABUF, &dmabuf);
+    if (ret < 0) {
+        return;
+    }
+    name = dmabuf.fd;
+    current_primary_fb_addr = dmabuf.start;
+    r = oldest_rec(&primary_list);
+    if (primary_list.l[r].fd > 0) {
+        printf("close primary fd:%d\n", primary_list.l[r].fd);
+        close(primary_list.l[r].fd);
+    }
+    primary_list.l[r].start = current_primary_fb_addr;
+    primary_list.l[r].textureId = textureId;
+    primary_list.l[r].age = 0;
+    primary_list.l[r].tiled = dmabuf.tiled;
+    primary_list.l[r].size = dmabuf.size;
+    primary_list.l[r].fd = dmabuf.fd;
+    fbWidth = dmabuf.width;
+    fbHeight = dmabuf.height;
+
+    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+    glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP, GL_TRUE);
+
+    EGLint attribs[] = {
+        EGL_WIDTH, dmabuf.width,
+        EGL_HEIGHT, dmabuf.height,
+        EGL_LINUX_DRM_FOURCC_EXT,
+        dmabuf.drm_format > 0 ? dmabuf.drm_format : DRM_FORMAT_ARGB8888,
+        EGL_DMA_BUF_PLANE0_FD_EXT, name,
+        EGL_DMA_BUF_PLANE0_OFFSET_EXT, 0,
+        EGL_DMA_BUF_PLANE0_PITCH_EXT, dmabuf.stride,
+        EGL_NONE
+    };
+    namedimage = eglCreateImageKHR(dpy, EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT,
+                                       NULL, attribs);
+    glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, namedimage);
+    eglDestroyImageKHR(dpy, namedimage);
+}
+
+static void check_for_new_primary_buffer(void)
+{
+    struct intel_vgpu_dmabuf dmabuf;
+    int r = 0;
+    uint32_t start;
+
+    memset(&dmabuf, 0, sizeof(struct intel_vgpu_dmabuf));
+    dmabuf.plane_id = INTEL_GVT_PLANE_PRIMARY;
+
+    r = kvmgt_fd_ioctl(kvmgt_fd, INTEL_VGPU_QUERY_DMABUF, &dmabuf);
+    if (r != 0 || dmabuf.start == 0) {
+        current_primary_fb_addr = 0;
+        return;
+    }
+    start = dmabuf.start;
+    if ((start != current_primary_fb_addr)) {
+        r = find_rec(&primary_list, &dmabuf);
+        age_list(&primary_list);
+        if (r >= 0) {
+            primary_list.l[r].age = 0;
+            current_textureId = primary_list.l[r].textureId;
+            current_primary_fb_addr = start;
+        } else {
+            create_primary_buffer();
+        }
+    }
+}
+
+static void check_for_new_cursor_buffer(int *x, int *y)
+{
+    struct intel_vgpu_dmabuf dmabuf;
+    int r;
+    uint32_t cursorstart;
+
+    memset(&dmabuf, 0, sizeof(struct intel_vgpu_dmabuf));
+    dmabuf.plane_id = INTEL_GVT_PLANE_CURSOR;
+
+    r = kvmgt_fd_ioctl(kvmgt_fd, INTEL_VGPU_GENERATE_DMABUF, &dmabuf);
+    if (r != 0 || dmabuf.start <= 0) {
+        current_cursor_fb_addr = 0;
+        cursor_ready = false;
+        return;
+    }
+    cursorstart = dmabuf.start;
+    cursor_ready = true;
+    if (cursorstart != current_cursor_fb_addr) {
+        current_cursor_fb_addr = cursorstart;
+        r = find_rec(&cursor_list, &dmabuf);
+        age_list(&cursor_list);
+        if (r >= 0) {
+            cursor_list.l[r].age = 0;
+            current_cursor_textureId = cursor_list.l[r].textureId;
+        } else {
+            create_cursor_buffer();
+        }
+    }
+
+    *x = dmabuf.x_pos;
+    *y = dmabuf.y_pos;
+}
+
+/********** UDEV Part ************/
+static struct udev * udev;
+static struct udev_monitor * mon;
+
+static int udev_init(void) {
+    int ret;
+
+    udev = udev_new();
+    if (!udev) {
+        return -1;
+    }
+
+    mon = udev_monitor_new_from_netlink(udev, "kernel");
+    if (!mon) {
+        ret = -2;
+        goto release_udev;
+    }
+
+    ret = udev_monitor_filter_add_match_subsystem_devtype(mon, "drm", NULL);
+    if (ret < 0) {
+        ret = -3;
+        goto release_mon;
+    }
+
+    ret = udev_monitor_enable_receiving(mon);
+    if (ret < 0) {
+        ret = -4;
+        goto release_mon;
+    }
+
+    return 0;
+
+release_mon:
+    udev_monitor_unref(mon);
+release_udev:
+    udev_unref(udev);
+
+    return ret;
+}
+
+static void udev_destroy(void) {
+    udev_monitor_unref(mon);
+    udev_unref(udev);
+}
+
+static int check_vgt_uevent(void) {
+    int ret = 0;
+    const char * value;
+    struct udev_device * dev;
+
+    dev = udev_monitor_receive_device(mon);
+    if (!dev) {
+        goto out;
+    }
+
+    value = udev_device_get_property_value(dev, "GVT_DISPLAY_READY");
+    if (!value || strcmp(value, "1")) {
+        goto out;
+    }
+    value = udev_device_get_property_value(dev, "VMID");
+    if (!value || 1 != sscanf(value, "%d", &ret) || ret != vgpuid) {
+        goto out;
+    }
+    ret = 1;
+out:
+    udev_device_unref(dev);
+
+    return ret;
+}
+
+/********** SDL Part ************/
+static DisplayChangeListener *dcl;
+/*
+extern int last_vm_running;
+
+void sdl_update_caption(void);
+*/
+void handle_keydown(SDL_Event *ev);
+void handle_keyup(SDL_Event *ev);
+void handle_mousemotion(SDL_Event *ev);
+void handle_mousebutton(SDL_Event *ev);
+void handle_activation(SDL_Event *ev);
+
+static void intel_vgt_refresh(DisplayChangeListener *dcl)
+{
+    SDL_Event event;
+    int x =0, y = 0;
+    //int ret;
+/*
+    if (last_vm_running != runstate_is_running()) {
+        last_vm_running = runstate_is_running();
+        sdl_update_caption();
+    }
+*/
+    SDL_EnableUNICODE(!qemu_console_is_graphic(NULL));
+
+    while (SDL_PollEvent(&event)) {
+        switch (event.type) {
+        case SDL_VIDEORESIZE:
+            SDL_SetVideoMode(event.resize.w, event.resize.h, 16,
+                             SDL_OPENGL | SDL_RESIZABLE);
+            reshape(event.resize.w, event.resize.h);
+            break;
+        case SDL_KEYDOWN:
+            handle_keydown(&event);
+            break;
+        case SDL_KEYUP:
+            handle_keyup(&event);
+            break;
+        case SDL_QUIT:
+            if (!no_quit) {
+                no_shutdown = 0;
+                qemu_system_shutdown_request();
+            }
+            break;
+        case SDL_MOUSEMOTION:
+            handle_mousemotion(&event);
+            break;
+        case SDL_MOUSEBUTTONDOWN:
+        case SDL_MOUSEBUTTONUP:
+            handle_mousebutton(&event);
+            break;
+        case SDL_ACTIVEEVENT:
+            handle_activation(&event);
+            break;
+        default:
+            break;
+        }
+    }
+
+    check_for_new_primary_buffer();
+    check_for_new_cursor_buffer(&x, &y);
+    draw(x, y);
+    eglSwapBuffers(dpy, sur);
+}
+
+static void vgt_init(void)
+{
+    glEGLImageTargetTexture2DOES = (PFNGLEGLIMAGETARGETTEXTURE2DOESPROC)
+    eglGetProcAddress("glEGLImageTargetTexture2DOES");
+    eglCreateImageKHR = (PFNEGLCREATEIMAGEKHRPROC)
+    eglGetProcAddress("eglCreateImageKHR");
+    eglDestroyImageKHR = (PFNEGLDESTROYIMAGEKHRPROC)
+    eglGetProcAddress("eglDestroyImageKHR");
+    int i;
+    EGLint attribs[] = {
+    EGL_SURFACE_TYPE, EGL_WINDOW_BIT, /* may be changed later */
+    EGL_RED_SIZE, 1,
+    EGL_GREEN_SIZE, 1,
+    EGL_BLUE_SIZE, 1,
+    EGL_DEPTH_SIZE, 1,
+    EGL_RENDERABLE_TYPE, EGL_OPENGL_BIT,
+    EGL_NONE
+    };
+    EGLint num_conf;
+    SDL_SysWMinfo info;
+    EGLConfig conf;
+
+    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
+    SDL_SetVideoMode(winWidth, winHeight, 32, SDL_OPENGL | SDL_RESIZABLE);
+
+    SDL_VERSION(&info.version);
+    SDL_GetWMInfo(&info);
+
+    eglBindAPI(EGL_OPENGL_API);
+    dpy = eglGetDisplay(info.info.x11.display);
+    eglInitialize(dpy, NULL, NULL);
+
+    eglChooseConfig(dpy, attribs, &conf, 1, &num_conf);
+    ctx = eglCreateContext(dpy, conf, EGL_NO_CONTEXT, NULL);
+    sur = eglCreateWindowSurface(dpy, conf, info.info.x11.window, NULL);
+    eglMakeCurrent(dpy, sur, sur, ctx);
+
+    primary_list.l = malloc(PRIMARY_LIST_LEN*sizeof(struct buffer_rec));
+    if (primary_list.l == NULL) {
+        fprintf(stderr, "allocate primary list failed\n");
+        exit(1);
+    }
+    primary_list.len = PRIMARY_LIST_LEN;
+    cursor_list.l = malloc(CURSOR_LIST_LEN*sizeof(struct buffer_rec));
+    if (cursor_list.l == NULL) {
+        fprintf(stderr, "allocate cursor list failed\n");
+        exit(1);
+    }
+    cursor_list.len = CURSOR_LIST_LEN;
+    for (i = 0; i < primary_list.len; i++) {
+        primary_list.l[i].start = 0;
+        primary_list.l[i].textureId = 0;
+        primary_list.l[i].age = INT_MAX;
+        primary_list.l[i].fd = 0;
+        primary_list.l[i].size = 0;
+        primary_list.l[i].tiled = 0;
+    }
+    for (i = 0; i < cursor_list.len; i++) {
+        cursor_list.l[i].start = 0;
+        cursor_list.l[i].textureId = 0;
+        cursor_list.l[i].age = INT_MAX;
+        cursor_list.l[i].fd = 0;
+        cursor_list.l[i].size = 0;
+        cursor_list.l[i].tiled = 0;
+    }
+
+    glEnable(GL_TEXTURE_2D);
+    glClearColor(0, 0, 0, 0);
+    glColor3f(1, 1, 1);
+
+    glMatrixMode(GL_PROJECTION);
+    glOrtho(-1, 1, -1, 1, -1, 1);
+    glMatrixMode(GL_MODELVIEW);
+
+    reshape(winWidth, winHeight);
+    }
+
+static void intel_vgt_detect(DisplayChangeListener *dcl);
+static const DisplayChangeListenerOps dcl_ops = {
+    .dpy_name = "intel_vgt",
+    .dpy_refresh = intel_vgt_detect,
+};
+
+static const DisplayChangeListenerOps dcl_ops2 = {
+    .dpy_name = "intel_vgt2",
+    .dpy_refresh = intel_vgt_refresh,
+};
+
+static void intel_vgt_detect(DisplayChangeListener *dcl)
+{
+    if (check_vgt_uevent()) {
+        udev_destroy();
+        unregister_displaychangelistener(dcl->next.le_next);
+        vgt_init();
+        dcl->ops = &dcl_ops2;
+        kvmgt_fd = kvmgt_get_anon_fd();
+        printf("kvmgt: intel ui: get anon fd:%d\n", kvmgt_fd);
+    }
+}
+
+static bool check_egl(void)
+{
+    EGLDisplay d = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+    bool ret = true;
+    char *egl_ext;
+
+    if (!eglInitialize(d, NULL, NULL)) {
+        fprintf(stderr, "eglInitialize failed\n");
+        exit(1);
+    }
+    egl_ext = (char *)eglQueryString(d, EGL_EXTENSIONS);
+    if (!strstr(egl_ext, "EGL_KHR_image_base")) {
+        fprintf(stderr, "no egl extensions found. Intel GVT-g indirect display will be disabled\n");
+        ret = false;
+    } else {
+        fprintf(stderr, "egl extensions found. Intel GVT-g indirect display will be enabled\n");
+        if (strstr(egl_ext, "EGL_EXT_image_dma_buf_import") &&
+            strstr(egl_ext, "EGL_MESA_image_dma_buf_export")) {
+            fprintf(stderr, "Use dma-buf to get guest framebuffer\n");
+        } else {
+            fprintf(stderr, "Use flink to get guest framebuffer\n");
+        }
+    }
+    eglTerminate(d);
+
+    return ret;
+}
+
+void intel_vgpu_display_init(DisplayState *ds, int full_screen, int no_frame)
+{
+    sdl_display_init(ds, full_screen, no_frame);
+    if (!check_egl()) {
+        return;
+    }
+    udev_init();
+    dcl = g_malloc0(sizeof(DisplayChangeListener));
+    dcl->ops = &dcl_ops;
+    register_displaychangelistener(dcl);
+}
diff --git a/ui/sdl.c b/ui/sdl.c
index d8cf5bc..d037ebd 100644
--- a/ui/sdl.c
+++ b/ui/sdl.c
@@ -64,6 +64,12 @@ static int scaling_active = 0;
 static Notifier mouse_mode_notifier;
 static int idle_counter;
 
+void handle_keydown(SDL_Event *ev);
+void handle_keyup(SDL_Event *ev);
+void handle_mousemotion(SDL_Event *ev);
+void handle_mousebutton(SDL_Event *ev);
+void handle_activation(SDL_Event *ev);
+
 #define SDL_REFRESH_INTERVAL_BUSY 10
 #define SDL_MAX_IDLE_COUNT (2 * GUI_REFRESH_INTERVAL_DEFAULT \
                             / SDL_REFRESH_INTERVAL_BUSY + 1)
@@ -552,7 +558,7 @@ static void toggle_full_screen(void)
     graphic_hw_update(NULL);
 }
 
-static void handle_keydown(SDL_Event *ev)
+void handle_keydown(SDL_Event *ev)
 {
     int mod_state;
     int keycode;
@@ -698,7 +704,7 @@ static void handle_keydown(SDL_Event *ev)
     }
 }
 
-static void handle_keyup(SDL_Event *ev)
+void handle_keyup(SDL_Event *ev)
 {
     int mod_state;
 
@@ -730,7 +736,7 @@ static void handle_keyup(SDL_Event *ev)
     }
 }
 
-static void handle_mousemotion(SDL_Event *ev)
+void handle_mousemotion(SDL_Event *ev)
 {
     int max_x, max_y;
 
@@ -754,7 +760,7 @@ static void handle_mousemotion(SDL_Event *ev)
     }
 }
 
-static void handle_mousebutton(SDL_Event *ev)
+void handle_mousebutton(SDL_Event *ev)
 {
     int buttonstate = SDL_GetMouseState(NULL, NULL);
     SDL_MouseButtonEvent *bev;
@@ -779,7 +785,7 @@ static void handle_mousebutton(SDL_Event *ev)
     }
 }
 
-static void handle_activation(SDL_Event *ev)
+void handle_activation(SDL_Event *ev)
 {
 #ifdef _WIN32
     /* Disable grab if the window no longer has the focus
diff --git a/vl.c b/vl.c
index b3c80d5..6347875 100644
--- a/vl.c
+++ b/vl.c
@@ -4525,7 +4525,10 @@ int main(int argc, char **argv, char **envp)
         curses_display_init(ds, full_screen);
         break;
     case DT_SDL:
+#if 0
         sdl_display_init(ds, full_screen, no_frame);
+#endif
+        intel_vgpu_display_init(ds, full_screen, no_frame);
         break;
     case DT_COCOA:
         cocoa_display_init(ds, full_screen);
-- 
1.9.1

